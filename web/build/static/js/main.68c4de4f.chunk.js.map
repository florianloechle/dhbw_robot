{"version":3,"sources":["components/Speech.js","lib/request.js","lib/animals.js","App.js","serviceWorker.js","index.js"],"names":["Speech","state","result","handleSpeech","event","_this$props","_this","props","startListening","listening","resetTranscript","prevProps","transcript","this","checkForMatches","_this2","_this$props2","targets","spoken","toLowerCase","Array","isArray","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","target","value","indexOf","setState","onRecognized","err","return","_this$props3","browserSupportsSpeechRecognition","react_default","a","createElement","className","onClick","clsx","role","aria-label","React","Component","SpeechRecognition","autoStart","continuous","_callee","endPoint","method","data","optionOverrides","_args","arguments","regenerator_default","wrap","_context","prev","length","fetch","Object","objectSpread","mode","cache","headers","Content-Type","redirect","referrer","body","JSON","stringify","abrupt","sent","stop","sendRequest","animals","tomato","dino","leopard","frog","turtle","animalMap","keys","reduce","animal","validAnimals","App","error","debug","connected","handleRecognized","concat","then","response","ok","status","components_Speech","class","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.68c4de4f.chunk.js","sourcesContent":["/** @format */\r\n\r\nimport React from 'react';\r\nimport SpeechRecognition from 'react-speech-recognition';\r\nimport clsx from 'clsx';\r\n\r\nclass Speech extends React.Component {\r\n  state = {\r\n    result: null,\r\n  };\r\n  componentDidUpdate(prevProps) {\r\n    if (\r\n      prevProps.transcript !== this.props.transcript &&\r\n      this.props.transcript !== ''\r\n    ) {\r\n      this.checkForMatches();\r\n    }\r\n  }\r\n  checkForMatches() {\r\n    const { transcript, targets, resetTranscript } = this.props;\r\n    const spoken = transcript.toLowerCase();\r\n    if (Array.isArray(targets)) {\r\n      for (let target of targets) {\r\n        if (spoken.indexOf(target.toLowerCase()) !== -1) {\r\n          resetTranscript();\r\n          return this.setState({ result: target }, () => {\r\n            this.props.onRecognized(this.state.result);\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      if (spoken.indexOf(targets.toLowerCase()) !== -1) {\r\n        resetTranscript();\r\n        return this.setState({ result: targets });\r\n      }\r\n    }\r\n  }\r\n  handleSpeech = event => {\r\n    const { startListening, listening, resetTranscript } = this.props;\r\n    if (!listening) {\r\n      startListening();\r\n    } else {\r\n      resetTranscript();\r\n    }\r\n  };\r\n  render() {\r\n    const { browserSupportsSpeechRecognition, listening } = this.props;\r\n    if (!browserSupportsSpeechRecognition) {\r\n      return (\r\n        <div className=\"speech disabled\">\r\n          <h4>Dein Browser unterstÃ¼tzt keine Spracheingabe!</h4>\r\n          <span role=\"img\" aria-label=\"crying emoji\">\r\n            ðŸ˜­\r\n          </span>\r\n        </div>\r\n      );\r\n    }\r\n    return (\r\n      <div className=\"speech-container\">\r\n        <button className=\"speech\" onClick={this.handleSpeech}>\r\n          <div className={clsx('mic', listening && 'active')}>\r\n            <div className=\"mic_body\">\r\n              <div className=\"mic_pill\" />\r\n              <div className=\"mic_hole\" />\r\n              <div className=\"mic_stand\" />\r\n              <div className=\"mic_bottom\" />\r\n            </div>\r\n            <div className=\"dots\">\r\n              <div className=\"dots_left\" />\r\n              <div className=\"dots_middle\" />\r\n              <div className=\"dots_right\" />\r\n            </div>\r\n          </div>\r\n        </button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SpeechRecognition({ autoStart: false, continuous: false })(\r\n  Speech\r\n);\r\n","\r\nasync function sendRequest(endPoint, method = 'POST', data = {}, optionOverrides = {}) {\r\n  return await fetch(endPoint, {\r\n    method: method,\r\n    mode: 'same-origin', // no-cors, cors, *same-origin\r\n    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n    },\r\n    redirect: 'follow', // manual, *follow, error\r\n    referrer: 'no-referrer', // no-referrer, *client\r\n    body: method === 'GET' ? undefined : JSON.stringify(data), // body data type must match \"Content-Type\" header\r\n    ...optionOverrides,\r\n  });\r\n}\r\n\r\nexport default sendRequest\r\n","/** @format */\r\n\r\nconst animals = {\r\n  tomato: [\r\n    'tomato',\r\n    'tomate',\r\n    'rot',\r\n    'rote',\r\n    'kugel',\r\n    'gemÃ¼se',\r\n    'ball',\r\n    'essen',\r\n  ],\r\n  dino: ['dinosaurier', 'dino', 'blau', 'blaue', 'kreidezeit'],\r\n  leopard: [\r\n    'leopard',\r\n    'schnell',\r\n    'schnellste',\r\n    'gefleckte',\r\n    'gefleckt',\r\n    'fleichfresser',\r\n  ],\r\n  frog: ['frosch', 'frog', 'grÃ¼n', 'grÃ¼ne'],\r\n  turtle: [\r\n    'schildkrÃ¶te',\r\n    'turtle',\r\n    'panzer',\r\n    'panzertier',\r\n    'wasser',\r\n    'langsam',\r\n    'langsamste',\r\n  ],\r\n};\r\n\r\nexport const animalMap = Object.keys(animals).reduce((animalMap,animal) => {\r\n  const validAnimals = animals[animal];\r\n  for(let validAnimal of validAnimals) {\r\n    animalMap[validAnimal] = animal\r\n  }\r\n  return animalMap\r\n},{})\r\n","/** @format */\r\n\r\nimport React from 'react';\r\nimport Speech from './components/Speech';\r\nimport sendRequest from './lib/request';\r\nimport { animalMap } from './lib/animals';\r\n\r\nconst animals = Object.keys(animalMap);\r\n\r\nclass App extends React.Component {\r\n  state = {\r\n    error: null,\r\n    debug: false,\r\n    animal: null,\r\n    connected: false,\r\n  };\r\n\r\n  handleRecognized = result => {\r\n    const animal = animalMap[result];\r\n    sendRequest(`/animal/${animal}`, 'POST').then(\r\n      response => {\r\n        if (response.ok) {\r\n          return this.setState({ animal });\r\n        } else {\r\n          switch (response.status) {\r\n            case 404:\r\n              this.setState({\r\n                error: 'Der Endpunkt wurde nicht gefunden.',\r\n                animal,\r\n              });\r\n              break;\r\n            default:\r\n              this.setState({\r\n                error:\r\n                  'Bei der Verbindung zum Server ist ein Fehler aufgetreten.',\r\n                animal,\r\n              });\r\n          }\r\n        }\r\n      },\r\n      error => {\r\n        return this.setState({ error });\r\n      }\r\n    );\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <header className=\"App-header\">\r\n          <h1>Spracheingabe</h1>\r\n        </header>\r\n        <div className=\"container grid-lg\">\r\n          <div className=\"columns controls\">\r\n            <div className=\"column col-12\">\r\n              <Speech onRecognized={this.handleRecognized} targets={animals} />\r\n            </div>\r\n            <div className=\"column col-12\">\r\n              {this.state.animal && (\r\n                <div className=\"toast toast-success\">\r\n                  <button\r\n                    onClick={() => this.setState({ animal: null })}\r\n                    class=\"btn btn-clear float-right\"\r\n                  />\r\n                  {'Erkannt ' + this.state.animal}\r\n                </div>\r\n              )}\r\n            </div>\r\n            <div className=\"column col-12\">\r\n              {this.state.error && (\r\n                <div className=\"toast toast-error\">\r\n                  <button\r\n                    class=\"btn btn-clear float-right\"\r\n                    onClick={() => this.setState({ error: null })}\r\n                  />\r\n                  {this.state.error}\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport './styles/global.css';\r\nimport 'spectre.css/dist/spectre.min.css'\r\nimport 'spectre.css/dist/spectre-icons.min.css'\r\nimport 'spectre.css/dist/spectre-exp.min.css'\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}